<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta
  name="description"
  content="PortFolio de Hideki Nishida, Aqui você descobre
  mais sobre mim e meu trabalho.">
    <link rel="stylesheet" href="styles.css">
    <title>Hideki Nishida | Home</title>
    <link id="favicon" rel="icon" type="image/svg+xml" href="assets/images/dp_male.svg">
    <link href="https://uploads-ssl.webflow.com/5e008677e65e063e42daedb6/css/three-js-stars.webflow.c1e54067c.css" rel="stylesheet" type="text/css">
    <meta property="og:image" content="assets/images/dp_male.svg">
    <script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
    <script defer src="assets/js/dynamicTitle.js"></script>
</head>
<body>
    <div id="BackgroundStars"></div>
    <div id="abertura">
        <div class="black-background"></div>
        <div class="animation-container">
            <div class="white-box">
                VN
            </div>
            <div id="nome-container" class="nome"></div>
        </div>
    </div>
    <div id="conteudo-do-site">
        <font align="center" color="white"><h1>Olá 
            <span class="wave">
                <img src="assets/images/Hand.gif" width="35px">
            </span>
            , Eu sou Vitor Hideki
        </h1>
        <h2>
        <span style="display: inline;">Eu sou 
            <span class="animated-text" data-words="Designer, Programador Web, Engenheiro de Software">

            </span>
        </span>
        <h2></font>
    </span>

    </div>
    <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.4.1.min.220afd743d.js" type="text/javascript" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
    <script src="https://uploads-ssl.webflow.com/5e008677e65e063e42daedb6/js/webflow.454736d9e.js" type="text/javascript"></script>
    <script src="assets/js/CharAnimation.js"></script>
    <script src="assets/js/script.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
    <script>
        (function() {
            'use strict';
            /* 	'To actually be able to display anything with Three.js, we need three things:
                A scene, a camera, and a renderer so we can render the scene with the camera.' 
                       
                       - https://threejs.org/docs/#Manual/Introduction/Creating_a_scene 		*/
        
            var scene, camera, renderer;
        
            /* We need this stuff too */
            var container, aspectRatio,
                HEIGHT, WIDTH, fieldOfView,
                nearPlane, farPlane,
                mouseX, mouseY, windowHalfX,
                windowHalfY, stats, geometry,
                starStuff, materialOptions, stars,
                scene, camera, renderer, uniforms;
        


          
               
            init();
            animate();

            function isMobileDevice() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}
            
            function init() {
                container = document.getElementById('BackgroundStars');
                document.body.style.overflow = 'hidden';
        
                HEIGHT = window.innerHeight;
                WIDTH = window.innerWidth;
                aspectRatio = WIDTH / HEIGHT;
                fieldOfView = 75;
                nearPlane = 1;
                farPlane = 1000;
                mouseX = 0;
                mouseY = 0;
        
                windowHalfX = WIDTH / 2;
                windowHalfY = HEIGHT / 2;
        


            /* 	fieldOfView — Camera frustum vertical field of view.
                    aspectRatio — Camera frustum aspect ratio.
                    nearPlane — Camera frustum near plane.
                    farPlane — Camera frustum far plane.	
                    - https://threejs.org/docs/#Reference/Cameras/PerspectiveCamera
                     In geometry, a frustum (plural: frusta or frustums) 
                     is the portion of a solid (normally a cone or pyramid) 
                     that lies between two parallel planes cutting it. - wikipedia.		*/
        
                camera = new THREE.PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane);
        
                //Z positioning of camera
        
                camera.position.z = farPlane / 2;
                
                scene = new THREE.Scene({antialias:true});
                scene.fog = new THREE.FogExp2( 0x000000, 0.0003 );
        
                // The wizard's about to get busy.
                starForge();
                
                //check for browser Support
                if (webGLSupport()) {
                    //yeah?  Right on...
                    renderer = new THREE.WebGLRenderer({alpha: true});
                    uniforms = { time: { type: "f", value: 1.0 } }; // Adicionamos um uniforme para o tempo
                    
                    starStuff = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: materialOptions.vertexShader,
                fragmentShader: materialOptions.fragmentShader,
                blending: materialOptions.blending
            });

                } else {
                    //No?  Well that's okay.
                    renderer = new THREE.CanvasRenderer();
                }
        

                renderer.setClearColor(0x000011, 1);

                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize( WIDTH, HEIGHT);
                container.appendChild(renderer.domElement);
        
                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                stats.domElement.style.right = '0px';
                container.appendChild( stats.domElement );
        
                window.addEventListener( 'resize', onWindowResize, false );

                if (isMobileDevice()) {
    window.addEventListener('deviceorientation', onDeviceMove, false);
} else {
    document.addEventListener('mousemove', onMouseMove, false);
}

                //document.addEventListener( 'mousemove', onMouseMove, false );
                
            }
        
            function animate() {
                requestAnimationFrame(animate);
                uniforms.time.value += 0.05;
                render();
                stats.update();
            }
        
        
            function render() {

                if (isMobileDevice()) {
        // Atualize a posição da câmera com base nos valores do sensor de movimento
        camera.position.x += ((mouseX * 3) - camera.position.x) * 0.005;
        camera.position.y += (((-mouseY) * 3) - camera.position.y) * 0.005;
    } else {
        // Mantenha o comportamento original do mouse para desktop
        camera.position.x += (mouseX - camera.position.x) * 0.005;
        camera.position.y += (-mouseY - camera.position.y) * 0.005;
    }
    
                camera.lookAt( scene.position );
                renderer.render(scene, camera);
            }
        
            function webGLSupport() {
                /* 	The wizard of webGL only bestows his gifts of power
                    to the worthy.  In this case, users with browsers who 'get it'.		*/
        
                try {
                    var canvas = document.createElement('canvas');
                    return !!(window.WebGLRenderingContext && (
                        canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
                    );
                } catch(e) {
                    // console.warn('Hey bro, for some reason we\'re not able to use webGL for this.  No biggie, we\'ll use canvas.');
                    return false;
                }
            }
        
            function onWindowResize() {
        
                // Everything should resize nicely if it needs to!
                  var WIDTH = window.innerWidth,
                      HEIGHT = window.innerHeight;
        
                  camera.aspect = aspectRatio;
                  camera.updateProjectionMatrix();
                  renderer.setSize(WIDTH, HEIGHT);
            }
        
            function starForge() {
                /* 	Yep, it's a Star Wars: Knights of the Old Republic reference,
                    are you really surprised at this point? 
                                                            */
                var starQty = 45000;
                    //geometry = new THREE.SphereGeometry(1000, 100, 50);
                    geometry = new THREE.CircleGeometry(1, 32);
                    materialOptions = {
                        size: 1.0, //I know this is the default, it's for you.  Play with it if you want.
                        transparency: true, 
                        opacity: 0.7,
                        color: 0x000011, // Altere a cor para branco para que as estrelas brilhem
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
    varying vec2 vUv;
    uniform float time;
    void main() {
        float pulse = sin(time) * 0.5 + 0.5;
        float intensity = smoothstep(0.02, 0.04, pulse);
        
        // Adicione variação de brilho com base na posição x da estrela
        float positionVariation = sin(gl_Position.x * 0.1) * 0.5 + 0.5;

        // Converta as coordenadas para o centro do círculo
        vec2 centeredCoords = vUv - 0.5;
        
        // Calcule a distância do ponto central
        float distanceToCenter = length(centeredCoords);

        // Defina um raio para o círculo
        float circleRadius = 0.5;

        // Use smoothstep para criar um gradiente suave ao redor do círculo
        float circle = smoothstep(circleRadius, circleRadius + 0.01, circleRadius - distanceToCenter);

        vec3 color = mix(vec3(1.0), vec3(1.0, 1.0, 0.8), intensity * positionVariation * circle);
        gl_FragColor = vec4(color, intensity);
    }
`,
    blending: THREE.AdditiveBlending
                    };
        
                    starStuff = new THREE.PointCloudMaterial(materialOptions);
        
                // The wizard gaze became stern, his jaw set, he creates the cosmos with a wave of his arms
        
                for (var i = 0; i < starQty; i++) {		
        
                    var starVertex = new THREE.Vector3();
                    starVertex.x = Math.random() * 2000 - 1000;
                    starVertex.y = Math.random() * 2000 - 1000;
                    starVertex.z = Math.random() * 2000 - 1000;
        
                    geometry.vertices.push(starVertex);
        
                }
        
        
                stars = new THREE.PointCloud(geometry, starStuff);
                scene.add(stars);
            }
        
            function onMouseMove(e) {
        
                
                mouseX = e.clientX - windowHalfX;
                mouseY = e.clientY - windowHalfY;
            }
            
            function onDeviceMove(event) {
    // Obtenha os valores de rotação
    var alpha = event.alpha || 0; // rotação em torno do eixo z
    var beta = event.beta || 0;   // rotação em torno do eixo x
    var gamma = event.gamma || 0; // rotação em torno do eixo y

    // Ajuste os valores conforme necessário
    // Aqui, você pode experimentar diferentes ajustes com base na orientação do dispositivo
    // Certifique-se de testar em vários dispositivos para obter o comportamento desejado

    // Atualize mouseX e mouseY com base nos valores de rotação
    mouseX = gamma;
    mouseY = beta;

}
        
        })();
        </script>
</body>
</html>
